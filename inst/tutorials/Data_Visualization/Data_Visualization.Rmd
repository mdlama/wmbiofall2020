---
title: "Data Visualization with ggplot2 (Part 1)"
author: "M. Drew LaMar"
output:
  learnr::tutorial:
    progressive: true
    allow_skip: true
runtime: shiny_prerendered
description: ""
---

<style>
img.center {
    display: block;
    margin-left: auto;
    margin-right: auto;
}

img.float-left {
    float: left;
    margin: 20px;
}
</style>

```{r libraries, include=FALSE}
library(learnr)
library(gradethis)
library(digest)
```

```{r tidyverse-setup, include=FALSE}
library(tidyverse)
library(xkcd)
```

```{r stemdata-setup, include=FALSE}
library(tidyverse)
library(xkcd)
stemdata <- read_csv("https://qubeshub.org/community/groups/introbiostats/File:/uploads/stemdata.csv")
```

```{r setup, include=FALSE}
learnr::tutorial_options(
  exercise.timelimit = 15,
  exercise.checker = gradethis::grade_learnr,
  exercise.eval = FALSE
)
```

# Data Visualization with ggplot2

```{r, echo=FALSE, out.width="75%", out.extra="class='center'"}
knitr::include_graphics("images/data-science-explore.png")
```
<center>
Caption: Image from ["R for Data Science"](https://r4ds.had.co.nz/explore-intro.html)
</center>
<br>
A model of the data life cycle from the free online book ["R for Data Science"](https://r4ds.had.co.nz/explore-intro.html) is shown above. The whirlpool in the middle, besides making you dizzy I'm sure, is one of the most rewarding parts of the process - data exploration! There are some important take home points from the "Explore" portion of the diagram:
 
 (1) Data might require **transformation** before proper **visualization**.
 (2) It is best to visualize your data _before_ you do statistical analysis (also known as statistical modeling).
 (3) Rarely if ever will you complete this cycle only once.
 (4) Iterate towards perfection. In other words, don't worry about perfectly formatted publication quality graphs and results. Exploration should be full of fun and curiosity. Save the publication quality results for the "Communicate" step.

In the previous tutorial, [Data Manipulation with dplyr](https://mdllama.shinyapps.io/Data_Manipulation), you learned about the tidyverse package `dplyr` and how to use it to **Transform** your data. In this tutorial, we will introduce you to the tidyverse package `ggplot2`, showing you how to use it to **Visualize** your data.

Helpful resources for this tutorial:

 - [ggplot2 Reference](https://ggplot2.tidyverse.org/index.html)
 - [ggplot2 Cheat Sheet](https://github.com/rstudio/cheatsheets/raw/master/data-visualization-2.1.pdf)
 - [R for Data Science: Data visualisation](https://r4ds.had.co.nz/data-visualisation.html) (Free online book chapter)
 - [ggplot2: Elegant Graphics for Data Analysis](https://ggplot2-book.org/) (Free online book)

## Introduction to ggplot2

```{r, echo=FALSE, out.height="100px",  out.extra="class='float-left'"}
knitr::include_graphics("images/hex-ggplot2.png")
```

> "ggplot2 is a system for declaratively creating graphics, based on [The Grammar of Graphics](https://amzn.to/2ef1eWp). You provide the data, tell ggplot2 how to map variables to aesthetics, what graphical primitives to use, and it takes care of the details." <br> <span style="float:right;"> - tidyverse.org</span>
<div style="clear: both;"></div>

<div style="clear: both;"></div>

Using `ggplot2` for your data visualization needs is akin to using a powerful photo or image editor, like Adobe Photoshop. When using modern image editors, there is a common process and language: The end result is composed of *layers* of overlapping content, one layer drawn on top of the other, with each layer utilizing aesthetics like color, position, space, and shape. This same language and creation paradigm can be applied to creating plots from data, which is exactly what **The Grammar of Graphics** aims to do. We get the added awesomeness, however, of learning how to map raw data to the visual aesthetics that we see in the final plot.

Most of the time, part of this mapping of data to visual objects requires some type of *data manipulation* or transformation, as Figure 1 illustrates. In order to truly understand and interpret a visual representation of data, one must know exactly how data is modified and mapped to the resulting plot. Some plots, such as *scatter plots*, are a direct mapping of the data to the image, while others like the bar plot may require some data processing before constructing the plot (e.g. computing frequencies of occurrences of levels for a categorical variable).

With The Grammar of Graphics, we break down the creation of a data visualization into 6 main components:

1. **Data**: Data used for the plot.
2. **Aesthetics**: Data generates geometric objects via _mapping_ data to general plot aesthetics (space, color, shape, size, etc.)
3. **Geoms**: Geometric objects, drawn in layers, that represent the data (points, lines, rectangles, curves, etc.)
4. **Statistics**: Processing of data into statistical summaries to show properties of your data, including uncertainty quantification and statistical models.
5. **Coordinates**: Coordinate systems and their properties (cartesian, polar, aspect ratios, axes limits, etc.)
6. **Themes**: Non-data elements of the plot (gridlines, ticks, labels, etc.)

As mentioned above, one of the key ideas of _The Grammar of Graphics_ is that visualizations can be composed of multiple layers, with each layer consisting of data, aesthetics, and geometric objects. As mentioned in the 3rd edition of the book [_ggplot2: Elegant Graphics for Data Analysis_](https://ggplot2-book.org/), by Hadley Wickham, Danielle Navarro, and Thomas Lin Pedersen, it is useful to think of each layer of a plot displayed for a purpose:

 (1) Plot **raw data** to show unprocessed patterns and structures in the data.
 (2) Plot **statistical summaries** to show central tendencies, uncertainty quantification, and summarized trends in the data.
 (3) Plot **metadata** to show annotations and helpful content to aid the reader in understanding and interpretation.

We map data to geometric objects through _aesthetics_, which is the focus of the next chapter.

Let's first take a look at one of the datasets we will be using for this tutorial.

## The Data

<div style="display: flex;">
<div style="flex: 1 0 50%;">
```{r, echo=FALSE, out.width="100%", out.extra="style='display:inline-block'"}
knitr::include_graphics("images/monarch-milkweed.jpg")
```
<br>Caption: Monarch butterfly on swamp milkweed.<br>JIM HUDGINS / USFWS MIDWEST REGION
</div>
<div style="flex: 1 0 50%;">
```{r, echo=FALSE, out.width="100%", out.extra="style='display:inline-block'"}
knitr::include_graphics("images/sites.png")
```
<br>Caption: Study sites across Virginia for milkweed trait measurements (Mary Seward, W&M)
</div>
</div>

The milkweed plant is the sole food source for the monarch butterfly. Milkweed is a long-lived perennial plant that can reproduce sexually and clonally through adventitious root sprouting. Though the belowground root system is perennial, the aboveground ramet population dies back annually. The plot on the right shows sites across Virginia where Professor Dalgleish's lab collected multiple measurements on milkweed over a five year period from 2013-2017. We will use this data over the remainder of this tutorial.

The following describes a subset of the variables in the data that we will explore in this tutorial:

 - `year`: Year at which the data was collected.
 - `site`: Unique site key denoting where in Virginia the data was collected, including Blandy Experimental Farm (**BLD1**, **BLD2**), Sky Meadows State Park (**SKY**), Presquile Wildlife Refuge (**PWR**), and Yorktown Battlefield Park (**YTB**).
 - `transect`: Each site had a varying number of transects that were 1 m wide, with variable lengths depending on the size of the milkweed patch.
 - `plantID`: Unique plant ID.
 - `h_apical`: Stem height to the apical meristem (cm), measured in June.
 - `h_apical.next`: Stem height to the apical meristem (cm), measured in September.
 - `herb_avg`: Herbivory severity score on a modified Daubenmire scale of 0–6 according to percent tissue removed (0 = intact, 1 = 1–5% removed, 2 = 6–24% removed, 3 = 25–50% removed, 4 = 51–75% removed, 5 = 76– 99% removed, 6 = only the petiole remains).

## Aesthetics and Geoms

**Aesthetics** can be thought of as _dimensions_ of general plot objects. For example, the following rectangle has seven aesthetic dimensions: center coordinate (x and y), width, height, border color, box color, and border width.

```{r, echo=FALSE, out.height="200px",  out.extra="class='center'"}
knitr::include_graphics("images/AestheticsBox.png")
```

The italicized words inside the parentheses correspond to aesthetic names used in `ggplot2`.

Here's our first `ggplot2` code that can display a rectangle just like the one above:

```{r geom-tile}
ggplot() + 
  geom_tile(mapping = aes(x = 0, y = 0), 
            width = 20, 
            height = 10,
            color = "green", 
            fill = "red", 
            size = 10)
```

The first command (`ggplot()`) creates a blank canvas and is required for all plots using `ggplot2`.

```{r blank-canvas}
ggplot()
```

The `+` command is similar to the data pipe `%>%` and can be thought of as either adding an additional layer to the plot (like in this case the tile geometric object) or adjusting parameters of the plot.

This is our first introduction to a **geom**, in this case `geom_tile`. 

> A **geom** is a plot algorithm that uses specified aesthetics to construct a geometric object in the coordinate plane.

In this case, the `geom_tile` function creates a rectangle using the aesthetics we specified above. Note that there is a similar geom, `geom_rect`, that will draw a rectangle using different aesthetics: in place of `x`, `y`, `width`, and `height`, `geom_rect` uses `xmin`, `xmax`, `ymin`, and `ymax`. For example, the same rectangle can be specified using the following bit of code.

```{r, fig.align="center"}
ggplot() + 
  geom_rect(mapping = aes(xmin = -10, xmax = 10, ymin = -5, ymax = 5),
            color = "green", 
            fill = "red",
            size = 10)
```

Which geom you use depends on which aesthetic specification is more convenient.

### Specifying aesthetics: Mappings or values?

In the commands above, you maybe have noticed some aesthetics are wrapped in the `aes()` function, which is then assigned to the `mapping` argument of the geom function, while others are specified as direct arguments to the geom function. Why the distinction? For right now, the rule is (1) required aesthetics for a geom need to be specified within the `aes()` function and assigned to the `mapping` variable, and (2) optional aesthetics for a geom can be specified as direct arguments to the geom function. We'll learn a more general rule later.

#### Exercise: Default aesthetics
*Plot a rectangle using* `geom_tile` *centered at (x,y) = (4, 7). Do not specify any other aesthetics.*

```{r one-tile-ex-1, exercise=TRUE, exercise.setup="tidyverse-setup"}

```

```{r one-tile-ex-1-hint-1}
ggplot() +
  geom_tile(___)
```

```{r one-tile-ex-1-hint-2}
ggplot() +
  geom_tile(mapping = aes(___))
```

```{r one-tile-ex-1-solution}
ggplot() +
  geom_tile(mapping = aes(x = 4, y = 7))
```

```{r one-tile-ex-1-check}
gradethis::grade_code()
```

It looks like the default aesthetics for a tile geom is a width and height of 1, no border, and a dark grey fill.

#### Exercise: Add some color
*Plot a rectangle using* `geom_rect` *with the bottom-left corner at (x,y) = (0,0) and upper-right corner at (2,4). Also set the fill to* `forestgreen` *and the color to* `goldenrod1`.

```{r one-tile-ex-2, exercise=TRUE, exercise.setup="tidyverse-setup"}

```

```{r one-tile-ex-2-hint-1}
ggplot() +
  geom_rect(mapping = aes(___))
```

```{r one-tile-ex-2-hint-2}
ggplot() +
  geom_rect(mapping = aes(xmin = ___, ymin = ___, xmax = ___, ymax = ___))
```

```{r one-tile-ex-2-hint-3}
ggplot() +
  geom_rect(mapping = aes(xmin = 0, ymin = 0, xmax = 2, ymax = 4),
            fill = ___,
            color = ___)
```

```{r one-tile-ex-2-solution}
ggplot() +
  geom_rect(mapping = aes(xmin = 0, ymin = 0, xmax = 2, ymax = 4),
            fill = "forestgreen",
            color = "goldenrod1")
```

```{r one-tile-ex-2-check}
gradethis::grade_code("Looks like a super small border size! The default is set to 0.1.")
```

### Multiple geoms: Using layers

Suppose we wanted two rectangles such that:

 (1) Rectangle #1 is the same as above, and
 (2) Rectangle #2 is centered at the upper right corner of Rectangle #1, with all other aesthetics the same except fill is black and the border is blue.
 
How can we create these? With `ggplot2`, all you have to do is combine two geom specifications with a `+` sign.

```{r}
ggplot() +
  geom_tile(mapping = aes(x = 0, y = 0), # red and green rectangle
            width = 20, 
            height = 10,
            color = "green", 
            fill = "red", 
            size = 10) +
  geom_tile(mapping = aes(x = 10, y = 5), # black and blue rectangle
            width = 20,
            height = 10,
            color = "blue",
            fill = "black",
            size = 10)
```

As you can see, the second layer (black and blue rectangle) is *on top of* the first layer (red and green rectangle).

#### Exercise: Change the order of the layers
*Repeat the code above that created the two rectangles, but this time call the black and blue* `geom_tile` *first. What do you expect to happen?*

```{r layers-ex-1, exercise=TRUE, exercise.setup="tidyverse-setup"}

```

```{r layers-ex-1-solution}
ggplot() +
  geom_tile(mapping = aes(x = 10, y = 5), # black and blue rectangle
            width = 20, 
            height = 10,
            color = "blue", 
            fill = "black", 
            size = 10) +
  geom_tile(mapping = aes(x = 0, y = 0), # red and green rectangle
            width = 20,
            height = 10,
            color = "green",
            fill = "red",
            size = 10)
```

```{r layers-ex-1-check}
gradethis::grade_code()
```

Remember the analogy to image processing programs like Photoshop: each geom is a *layer*, and the layers are drawn on top of each other in the order they are specified. What if we still want to see the object behind the other one? Each geom has an *alpha transparency* aesthetic, specified between 0 (fully transparent) and 1 (opaque), that allows you to _see through_ each layer.

#### Exercise: Specify transparency
*Set the value of the red and green rectangle's transparency (or aesthetic* `alpha`*) to 0.6.*

```{r transp-ex-1, exercise=TRUE, exercise.setup="tidyverse-setup", exercise.eval=TRUE}
ggplot() +
  geom_tile(mapping = aes(x = 10, y = 5), # black and blue rectangle
            width = 20, 
            height = 10,
            color = "blue", 
            fill = "black", 
            size = 10) +
  geom_tile(mapping = aes(x = 0, y = 0), # red and green rectangle
            width = 20,
            height = 10,
            color = "green",
            fill = "red",
            size = 10)
```

```{r transp-ex-1-solution}
ggplot() +
  geom_tile(mapping = aes(x = 10, y = 5), # red and green rectangle
            width = 20, 
            height = 10,
            color = "blue", 
            fill = "black", 
            size = 10) +
  geom_tile(mapping = aes(x = 0, y = 0), # black and blue rectangle
            width = 20,
            height = 10,
            color = "green",
            fill = "red",
            size = 10,
            alpha = 0.6)
```

```{r transp-ex-1-check}
gradethis::grade_code()
```

### Multiple geoms: Utilizing the data frame

What if we want to draw lots of tiles/rectangles at the same time, with many of them sharing the same aesthetics? We could add a new `geom_tile` layer every time we wanted a new tile, but this could quickly get out of hand. A shortcut is to create a data frame that stores the aesthetics that vary across rectangles. For example, if we wanted to draw the two rectangles above, but this time keep them both the same colors to make things easier, we could create a data frame or tibble with differing center coordinates as follows (see [this link](https://rstudio-education.github.io/tidyverse-cookbook/tidy.html#create-a-tibble-manually) for an introduction to tribbles):

```{r tribble}
tiles <- tribble(
  ~xcoord, ~ycoord,
  10, 5,
  0, 0
)
```

With this data frame, we can then pass the `tiles` data to `ggplot` and *map* the aesthetics to the corresponding variables in the data, as follows:

```{r map-aesthetics}
ggplot(data = tiles) +
  geom_tile(mapping = aes(x = xcoord, y = ycoord),
            width = 20,
            height = 10,
            size = 10,
            fill = "red",
            color = "green")
```

Nice! What we see is that rather than needing two `geom_tile` commands, we only need one by passing in the variable aesthetics as a data frame and mapping those variables to appropriate aesthetics. Each row of the data frame corresponds to aesthetics for an individual tile.

We can now discuss in full generality which aesthetics go in the `aes()` function and get assigned to the `mapping` argument, and which aesthetics go outside the `aes()` function as arguments to the geom.

> Aesthetics that are **mapped from variables** in a data frame or tibble should be set in the `aes()` function and assigned to the `mapping` argument. Aesthetics that are **not mapped from variables**, but are instead meant to be _constant_ across all geom instances, can be assigned as direct arguments to the geom. The only exception to the constant aesthetic rule is when the aesthetic is required - in this case, even if it is a constant, a required aesthetic needs to be specified within the `aes()` function.

Why did this example not have varying colors and fills, as the previous examples did? To specify varying colors in the data requires a discussion about **scales**, which we will get to in the next section of this tutorial.

#### Exercise: Go Tribe (x4)!
*Draw four rectangles with the following properties:*

 - *One rectangle each centered at (1,1), (1,-1), (-1,-1), and (-1,1).*
 - *Fill is* `forestgreen` *and border (*`color`*) is *`goldenrod1`*.*
 - *Width and height are both 1.*
 - *Size of border is 2.*
*Do this by first creating a data frame or tibble named* `tiles` *that stores the* `x` *and* `y` *values (which vary across rectangles), and then pass this data to the* `ggplot` *function. Note that the other aesthetics _do not vary_ across the four rectangles (i.e. are constants).*

```{r go-tribe-ex-1, exercise=TRUE, exercise.setup="tidyverse-setup"}

```

```{r go-tribe-ex-1-hint-1}
tiles <- tribble(
  ___
)

ggplot() +
  geom_tile(___)
```

```{r go-tribe-ex-1-hint-2}
tiles <- tribble(
  ~x, ~y,
  1, 1,
  1, -1,
  -1, -1,
  -1, 1
)

ggplot(data = ___) +
  geom_tile(mapping = aes(___))
```

```{r go-tribe-ex-1-hint-3}
tiles <- tribble(
  ~x, ~y,
  1, 1,
  1, -1,
  -1, -1,
  -1, 1
)

ggplot(data = tiles) +
  geom_tile(mapping = aes(x = x, y = y),
            ___)
```

```{r go-tribe-ex-1-solution}
tiles <- tribble(
  ~x, ~y,
  1, 1,
  1, -1,
  -1, -1,
  -1, 1)

ggplot(data = tiles) +
  geom_tile(mapping = aes(x = x, y = y),
            width = 1,
            height = 1,
            size = 2,
            fill = "forestgreen",
            color = "goldenrod1")
```

```{r go-tribe-ex-1-check}
gradethis::grade_code()
```

The `geom_rect` and `geom_tile` geoms are examples of *primitive geoms*. Primitive geoms map the aesthetics to the geometric objects *directly and without any additional transformations*. Primitive geoms are the "what-you-code-is-what-you-get" type of geoms. There are two other main primitive geoms for drawing one-dimensional objects (**line segments**) and zero-dimensional objects (**points**):

 - **Points** are drawn with `geom_point` and require the aesthetics `x` and `y`.
 - **Lines** are drawn with `geom_segment` and require the aesthetics `x`, `y`, `xend` and `yend`.
 
#### Exercise: Adding points
*Starting with the four rectangles from the previous exercise, add points of size 5 at the center of the rectangles.*

```{r adding-points-ex-1, exercise=TRUE, exercise.setup="tidyverse-setup", exercise.eval=TRUE}
tiles <- tribble(
  ~x, ~y,
  1, 1,
  1, -1,
  -1, -1,
  -1, 1)

ggplot(data = tiles) +
  geom_tile(mapping = aes(x = x, y = y),
            width = 1,
            height = 1,
            size = 2,
            fill = "forestgreen",
            color = "goldenrod1")
```

```{r adding-points-ex-1-hint-1}
tiles <- tribble(
  ~x, ~y,
  1, 1,
  1, -1,
  -1, -1,
  -1, 1)

ggplot(data = tiles) +
  geom_tile(mapping = aes(x = x, y = y),
            width = 1,
            height = 1,
            size = 2,
            fill = "forestgreen",
            color = "goldenrod1") +
  geom_point(___)
```

```{r adding-points-ex-1-hint-2}
tiles <- tribble(
  ~x, ~y,
  1, 1,
  1, -1,
  -1, -1,
  -1, 1)

ggplot(data = tiles) +
  geom_tile(mapping = aes(x = x, y = y),
            width = 1,
            height = 1,
            size = 2,
            fill = "forestgreen",
            color = "goldenrod1") +
  geom_point(mapping = aes(___))
```

```{r adding-points-ex-1-solution}
tiles <- tribble(
  ~x, ~y,
  1, 1,
  1, -1,
  -1, -1,
  -1, 1)

ggplot(data = tiles) +
  geom_tile(mapping = aes(x = x, y = y),
            width = 1,
            height = 1,
            size = 2,
            fill = "forestgreen",
            color = "goldenrod1") +
  geom_point(mapping = aes(x = x, y = y),
             size = 5)
```

```{r adding-points-ex-1-check}
gradethis::grade_code()
```

#### Exercise: Adding line segments
*Starting with the data and geoms from the previous two exercises (rectangles and points), add line segments of* `size` *1 that connect:*

 - *Point (1,1) to point (1,-1)*
 - *Point (1,-1) to point (-1,-1)*
 - *Point (-1,-1) to point (-1,1)*
 - *Point (-1,1) to point (1,1)*

*Start by adding two new variables to the* `tiles` *tibble called* `xend` *and* `yend`.

```{r adding-lines-ex-1, exercise=TRUE, exercise.setup="tidyverse-setup"}
tiles <- tribble(
  ~x, ~y,
  1, 1,
  1, -1,
  -1, -1,
  -1, 1)

ggplot(data = tiles) +
  geom_tile(mapping = aes(x = x, y = y),
            width = 1,
            height = 1,
            size = 2,
            fill = "forestgreen",
            color = "goldenrod1") +
  geom_point(mapping = aes(x = x, y = y),
             size = 5)
```

```{r adding-lines-ex-1-hint-1}
tiles <- tribble(
  ~x, ~y, ~xend, ~yend,
  1, 1, 1, -1,
  1, -1, -1, -1,
  -1, -1, -1, 1,
  -1, 1, 1, 1)

ggplot(data = tiles) +
  geom_tile(mapping = aes(x = x, y = y),
            width = 1,
            height = 1,
            size = 2,
            fill = "forestgreen",
            color = "goldenrod1") +
  geom_point(mapping = aes(x = x, y = y),
             size = 5) +
  geom_segment(mapping = aes(___),
               size = ___)
```

```{r adding-lines-ex-1-solution}
tiles <- tribble(
  ~x, ~y, ~xend, ~yend,
  1, 1, 1, -1,
  1, -1, -1, -1,
  -1, -1, -1, 1,
  -1, 1, 1, 1)

ggplot(data = tiles) +
  geom_tile(mapping = aes(x = x, y = y),
            width = 1,
            height = 1,
            size = 2,
            fill = "forestgreen",
            color = "goldenrod1") +
  geom_point(mapping = aes(x = x, y = y),
             size = 5) +
  geom_segment(mapping = aes(x = x, y = y, xend = xend, yend = yend),
               size = 1)
```

```{r adding-lines-ex-1-check}
gradethis::grade_code()
```

### Multiple geoms: Setting defaults

You may have noticed in the last exercise that there were some repetitive aesthetic mappings. Which aesthetics were mapped to the same variables in all geoms? The _x_ and _y_ aesthetics! In this case, we could specify these aesthetics in the `ggplot()` function.

```{r}
tiles <- tribble(
  ~x, ~y, ~xend, ~yend,
  1, 1, 1, -1,
  1, -1, -1, -1,
  -1, -1, -1, 1,
  -1, 1, 1, 1
)

ggplot(data = tiles,
       mapping = aes(x = x, y = y)) +
  geom_tile(width = 1,
            height = 1,
            size = 2,
            fill = "forestgreen",
            color = "goldenrod1") +
  geom_point(size = 5) +
  geom_segment(mapping = aes(xend = xend, yend = yend),
               size = 1)
```

Specifying aesthetic mappings in the `ggplot()` function is akin to _setting default aesthetic mappings for all of your geoms to follow_. If needed, you can override those defaults for any subsequent geom layer you specify.

There are lots of other geoms out there to explore! We will learn about many more of them in Part 2 of this course. First, however, we need to learn about _scales_.

## Scales and Statistics

The next two concepts, *scales* and *statistics*, dig a little deeper under the hood of `ggplot2` and detail how your original data is mapped to the visual aesthetics.

### Scales

```{r, echo=FALSE, out.height="100px",  out.extra="class='float-left'"}
knitr::include_graphics("images/hex-scales.png")
```

> Scales in `ggplot2` define how your data is mapped to visual aesthetics, including the handling of axes and legends.
<div style="clear: both;"></div>

Scales are somewhat unique in their actions and results, depending intimately on which aesthetic they correspond to. However, the two most important "scale types" include:

 - Location scales, like `x` and `y` (which get mapped to **axes**)
 - Color scales, like `fill` and `color` (which get mapped to **legends**) 
 - Other scales, like `size` and `linetype` (which also get mapped to **legends**)

All scales in `ggplot2` are functions of the form `scale_<aesthetic>_<scale name>()`. If an aesthetic is mapped, either explicitly in your code or implicitly by `ggplot2`, a default scale is used. Calling the appropriate scale function will allow the user to override the defaults.

Axes and legends are collectively known as **guides** in `ggplot2`. To control guides, every scale function has the three arguments in the table below:

| **Argument name** | **Axis**           | **Legend** |
| :---------------- | :----------------- | :--------- |
| `name`            | Label              | Title      |
| `breaks`          | Ticks & grid lines | Key        |
| `labels`          | Tick label         | Key label  |

```{r, echo=FALSE, out.width="400px", out.extra="class='center'"}
knitr::include_graphics("images/scale-guides.png")
```

Let's go into the two main types of scales individually, starting with _location scales_.

#### Location scales

Location scales perform the following:

 - **Set axes labels**
 - **Set tick marks and labels**
 - **Adjust axes limits**
 - **Axis transformations**

The most important scale functions for location aesthetics are `scale_x_discrete()`, `scale_x_continuous()`, `scale_y_discrete()`, and `scale_y_continuous()`. The choice of `discrete` or `continuous` should depend, of course, on whether the mapped variable is discrete or continuous.

##### Location scales: Set axes labels

To apply a scale for an aesthetic, you add the scale as if it were a geom with the `+` operator. Note that this is a little inaccurate - you are not adding a scale so much as you are modifying the existing default scale.

In the following example, we will modify the horizontal and vertical axis labels by setting the `name` argument in the `scale_x_continuous` and `scale_y_continuous` functions.

```{r}
ggplot(data = tiles,
       mapping = aes(x = x, y = y)) +
  geom_tile(width = 1,
            height = 1,
            size = 2,
            fill = "forestgreen",
            color = "goldenrod1") +
  geom_point(size = 5) +
  geom_segment(mapping = aes(xend = xend, yend = yend),
               size = 1) +
  scale_x_continuous(name = "Horizontal Axis") +
  scale_y_continuous(name = "Vertical Axis")
```

Note that there is a helper function in `ggplot2` for setting labels for all axes and legends: the `labs` function. You use the `labs` function as follows:

```{r, eval=FALSE}
labs(
  <aesthetic> = <label name>,
  <aesthetic> = <label name>,
  ...)
```

Here is an example that applies the same axes labels as before:
```{r}
ggplot(data = tiles,
       mapping = aes(x = x, y = y)) +
  geom_tile(width = 1,
            height = 1,
            size = 2,
            fill = "forestgreen",
            color = "goldenrod1") +
  geom_point(size = 5) +
  geom_segment(mapping = aes(xend = xend, yend = yend),
               size = 1) +
  labs(x = "Horizontal Axis",
       y = "Vertical Axis")
```

The `tiles` dataset below will be available for the next few exercises.

```{r tiles-setup, include=FALSE}
library(tidyverse)
tiles <- tribble(
  ~x, ~y, ~xend, ~yend,
  1, 1, 1, -1,
  1, -1, -1, -1,
  -1, -1, -1, 1,
  -1, 1, 1, 1
)
```

##### Exercise: Set tick marks
*Starting with the previous plot, change the tick marks by setting the* `breaks` *argument for each of the* `x` *and* `y` *scales. Create ticks that go from -1.5 to 1.5 in increments of 0.5. Hint: Use the* `seq` *function for the tick marks!*

> The `breaks` argument is a numeric vector of positions.

```{r tick-marks-ex-1, exercise=TRUE, exercise.setup="tiles-setup", exercise.eval = TRUE}
ggplot(data = tiles,
       mapping = aes(x = x, y = y)) +
  geom_tile(width = 1,
            height = 1,
            size = 2,
            fill = "forestgreen",
            color = "goldenrod1") +
  geom_point(size = 5) +
  geom_segment(mapping = aes(xend = xend, yend = yend),
               size = 1) +
  scale_x_continuous(name = "Horizontal Axis") +
  scale_y_continuous(name = "Vertical Axis")
```

```{r tick-marks-ex-1-solution}
ggplot(data = tiles,
       mapping = aes(x = x, y = y)) +
  geom_tile(width = 1,
            height = 1,
            size = 2,
            fill = "forestgreen",
            color = "goldenrod1") +
  geom_point(size = 5) +
  geom_segment(mapping = aes(xend = xend, yend = yend),
               size = 1) +
  scale_x_continuous(name = "Horizontal Axis",
                     breaks = seq(-1.5, 1.5, by = 0.5)) +
  scale_y_continuous(name = "Vertical Axis",
                     breaks = seq(-1.5, 1.5, by = 0.5))
```

```{r tick-marks-ex-1-check}
gradethis::grade_code()
```

##### Exercise: Set tick marks and labels
*Replicate the tick marks and labels for the following plot. Use the scale argument* `labels` *to set the labels as seen below.*

> The `labels` argument is a character vector giving labels (must be same length as `breaks`).

```{r, echo=FALSE, fig.width=4, fig.align="center"}
ggplot(data = tiles,
       mapping = aes(x = x, y = y)) +
  geom_tile(width = 1,
            height = 1,
            size = 2,
            fill = "forestgreen",
            color = "goldenrod1") +
  geom_point(size = 5) +
  geom_segment(mapping = aes(xend = xend, yend = yend),
               size = 1) +
  scale_x_continuous(name = "Horizontal Axis",
                     breaks = c(-1, 1),
                     labels = c("A", "B")) +
  scale_y_continuous(name = "Vertical Axis",
                     breaks = c(-1, 1),
                     labels = c("C", "D"))
```

```{r scale-labels-ex-1, exercise=TRUE, exercise.setup="tiles-setup", exercise.eval = TRUE}
ggplot(data = tiles,
       mapping = aes(x = x, y = y)) +
  geom_tile(width = 1,
            height = 1,
            size = 2,
            fill = "forestgreen",
            color = "goldenrod1") +
  geom_point(size = 5) +
  geom_segment(mapping = aes(xend = xend, yend = yend),
               size = 1)
```

```{r scale-labels-ex-1-hint-1}
ggplot(data = tiles,
       mapping = aes(x = x, y = y)) +
  geom_tile(width = 1,
            height = 1,
            size = 2,
            fill = "forestgreen",
            color = "goldenrod1") +
  geom_point(size = 5) +
  geom_segment(mapping = aes(xend = xend, yend = yend),
               size = 1) +
  scale_x_continuous(name = "Horizontal Axis",
                     breaks = c(__, __),
                     labels = c(__, __)) +
  scale_y_continuous(name = "Vertical Axis",
                     breaks = c(__, __),
                     labels = c(__, __))
```

```{r scale-labels-ex-1-solution}
ggplot(data = tiles,
       mapping = aes(x = x, y = y)) +
  geom_tile(width = 1,
            height = 1,
            size = 2,
            fill = "forestgreen",
            color = "goldenrod1") +
  geom_point(size = 5) +
  geom_segment(mapping = aes(xend = xend, yend = yend),
               size = 1) +
  scale_x_continuous(name = "Horizontal Axis",
                     breaks = c(-1, 1),
                     labels = c("A", "B")) +
  scale_y_continuous(name = "Vertical Axis",
                     breaks = c(-1, 1),
                     labels = c("C", "D"))
```

```{r scale-labels-ex-1-check}
gradethis::grade_code()
```

See ["Position scales and axes"](https://ggplot2-book.org/scale-position.html) for more advanced specifications.

##### Exercise: Adjust axes limits
*We can also modify a location aesthetic scale to change the limits of the axis by using the* `limits` *argument. Starting with the plot below, constrain the x axis so that* $0 \leq x \leq 2$*.*

> The `limits` argument is a numeric vector of length two providing limits of the scale. Use NA to refer to the existing minimum or maximum.

```{r limits-ex-1, exercise=TRUE, exercise.setup="tiles-setup", , exercise.eval = TRUE}
ggplot(data = tiles,
       mapping = aes(x = x, y = y)) +
  geom_tile(width = 1,
            height = 1,
            size = 2,
            fill = "forestgreen",
            color = "goldenrod1") +
  geom_point(size = 5) +
  geom_segment(mapping = aes(xend = xend, yend = yend),
               size = 1)
```

```{r limits-ex-1-solution}
ggplot(data = tiles,
       mapping = aes(x = x, y = y)) +
  geom_tile(width = 1,
            height = 1,
            size = 2,
            fill = "forestgreen",
            color = "goldenrod1") +
  geom_point(size = 5) +
  geom_segment(mapping = aes(xend = xend, yend = yend),
               size = 1) +
  scale_x_continuous(limits = c(0, 2))
```

```{r limits-ex-1-check}
gradethis::grade_code()
```

What, what?? What happened to our horizontal lines?! Setting the limits using the scale functions is different than just zooming in. By default, `ggplot2` will set the values of any data outside the limits to NA. Thus, the horizontal lines in this example will have one endpoint set to NA, and therefore _will not be drawn_. Thus, the default behavior in ggplot2 is to zoom **and** clip. 

What if you want to keep the values that are "out of bounds" (i.e. no clipping)? There is an argument to the scales function called `oob` that specifies this. By default, the argument is `oob = scales::oob_censor` which, as we stated previously, sets out of bound values to NA. This notation says _"use the_ `oob_censor()` _function in the_ `scales` _package to handle data that is out of bounds."_ 

[This reference sheet](https://scales.r-lib.org/reference/oob.html) lists all of the options for handling out of bound data. Probably the most important other `oob` function is `scales::oob_keep`, which will keep the data, thereby performing a more standard zoom.

#### Exercise: No clipping!
*Change the default out-of-bound behavior by setting the* `oob` *argument for the* `x` *scale to* `scales::oob_keep`*.*

```{r oob-ex-1, exercise=TRUE, exercise.setup="tiles-setup", , exercise.eval = TRUE}
ggplot(data = tiles,
       mapping = aes(x = x, y = y)) +
  geom_tile(width = 1,
            height = 1,
            size = 2,
            fill = "forestgreen",
            color = "goldenrod1") +
  geom_point(size = 5) +
  geom_segment(mapping = aes(xend = xend, yend = yend),
               size = 1) +
  scale_x_continuous(limits = c(0, 2))
```

```{r oob-ex-1-solution}
ggplot(data = tiles,
       mapping = aes(x = x, y = y)) +
  geom_tile(width = 1,
            height = 1,
            size = 2,
            fill = "forestgreen",
            color = "goldenrod1") +
  geom_point(size = 5) +
  geom_segment(mapping = aes(xend = xend, yend = yend),
               size = 1) +
  scale_x_continuous(limits = c(0, 2),
                     oob = scales::oob_keep)
```

```{r oob-ex-1-check}
gradethis::grade_code()
```

That's better! But wait - why is _zoom and clip_ (`oob_censor`) and not just _zoom_ (`oob_keep()`) the default behavior? Clipping will make more sense when we discuss statistics in Part 2 of this tutorial.

#### Location scales: Axis transformations

Besides setting axes labels, tick marks, and clipping/zooming, scales can also explicitly define the transformation from your data to the aesthetic (axis). By default, location scales do NOT perform a transformation, i.e. they perform an identity mapping between your data and the axes. There are times, however, when you will want to change this. We will cover one of the more common transformations - log transformations.

To illustrate transformations, let's revisit the milkweed data. The following creates a scatter plot of herbivory average versus apical stem height in June (cm). For simplicity, we first filter out where herbivory average is 0. In the code below, note that we can pipe the filtered data into the `ggplot()` function since the `data` argument is the first argument. We also do not explicitly specify the `mapping` argument in `geom_point` since it too is the first argument of all geoms.

```{r stemdata-scatter}
stemdata %>%
  filter(herb_avg > 0) %>%
  ggplot() +
  geom_point(aes(x = h_apical,
                 y = herb_avg))
```

Hmmm, it looks like most of the data is scrunched along the y-axis near 0. It might be nice to stretch the vertical axis near zero (kind of like a nonlinear zoom), while not stretching (or even shrinking) the vertical axis near the maximum of 6. A common way to do this is to use a log transformation. We can specify a log transformation by setting the `trans` argument of the y aesthetic scale to `log10`.

```{r stemdata-scatter-log}
stemdata %>%
  filter(herb_avg > 0) %>%
  ggplot() +
  geom_point(aes(x = h_apical,
                 y = herb_avg)) +
  scale_y_continuous(trans = "log10")
```

Note that the y axis label and values of the tick marks on the vertical axis are still showing the units of the data (herbivory average is measured from 0 to 6), and that while the tick marks are evenly spaced, the differences between tick marks are not!

> Rather than transforming the data, scale transformations are best thought of as nonlinear zooming along the relevant axis. 
 
It appears that 0-0.3 was _stretched_, whereas 0.3-6 was _squished_, and that the rate of stretching and squishing varies across the axis (proportional to the derivative of the transformation function at each point).

To illustrate the difference between transforming the data and transforming the axis, let's perform the same plot but calculate ourselves the log (base 10) of herbivory average.

```{r}
stemdata %>%
  filter(herb_avg > 0) %>%
  mutate(log_herb_avg = log10(herb_avg)) %>%
  ggplot() +
  geom_point(aes(x = h_apical,
                 y = log_herb_avg))
```

The points look the same, but you may notice that (1) the label is now `log_herb_avg`, and (2) the minimum is around -1.5 in this plot, which corresponds to $10^{-1.5} \approx 0.03$ on the previous plot. Thus, the vertical axis is now showing the exponents, which while accurately depicting the log scale can be harder to interpret.

Check out [Section 14.2: Scale transformation](https://ggplot2-book.org/scales-guides.html#scale-transformation) in _ggplot2: Elegant Graphics for Data Analysis_ for a list of common transformations.

##### Exercise: Can you spare a square root?
*Starting with the plot below and referring to Section 14.2 of the above link, use a square root mapping of herbivory average to the y aesthetic.*

```{r spare-square-root-ex-1, exercise=TRUE, exercise.setup="stemdata-setup", exercise.eval=TRUE}
stemdata %>%
  filter(herb_avg > 0) %>%
  ggplot() +
  geom_point(aes(x = h_apical,
                 y = herb_avg))
```

```{r spare-square-root-ex-1-solution}
stemdata %>%
  filter(herb_avg > 0) %>%
  ggplot() +
  geom_point(aes(x = h_apical,
                 y = herb_avg)) +
  scale_y_continuous(trans = "sqrt")
```

```{r spare-square-root-ex-1-check}
gradethis::grade_code("Not bad. For some data, square roots perform better than logs when you want to stretch values near zero (not in this case, though!).")
```

#### Color scales

Besides location aesthetics, the most commonly used aesthetic is based on color (via `color` or `fill`).

Color scales perform many of the same actions as location scales:

 - **Define palettes**
 - **Set legend titles**
 - **Set legend keys and key labels**
 - **Adjust key limits**
 - **Key transformations**

Here's the picture of a scatter plot with x, y, and a discrete color scale from before (for reference):
```{r, echo=FALSE, out.width="400px", out.extra="class='center'"}
knitr::include_graphics("images/scale-guides.png")
```

There are many different palettes available in `ggplot2`, each of which depends strongly on whether the data mapping to the aesthetic is discrete or continuous. The following table summarizes the main ggplot2 color scales:

| Palette | Discrete | Continuous | Resources |
| :------ | :------- | :--------- | :-------- |
| [HCL](https://ggplot2.tidyverse.org/reference/scale_hue.html) | `scale_*_hue` | - | [More info](http://hclwizard.org/) |
| [Viridis](https://ggplot2.tidyverse.org/reference/scale_viridis.html) | `scale_*_viridis_d` | `scale_*_viridis_c` | [More info](https://cran.r-project.org/web/packages/viridis/vignettes/intro-to-viridis.html) |
| [ColorBrewer](https://ggplot2.tidyverse.org/reference/scale_brewer.html) | `scale_*_brewer` | `scale_*_distiller` | [More info](https://colorbrewer2.org) |
| [Gradient](https://ggplot2.tidyverse.org/reference/scale_gradient.html) | - | `scale_*_gradient` | [More info](https://scales.r-lib.org//reference/seq_gradient_pal.html) |

##### Color scales: Define palettes

While location scales by default map data directly to their respective axes with no changes (i.e. they perform an identity mapping), this is not so for color. This is because there is no inherent natural way to map a continuous or discrete variable to a color scale. Which scale do we use? There are infinitely many of them!

By default, for discrete scales `ggplot2` maps to the [HCL color scale](http://hclwizard.org/#hcl-color-space) (H = Hue, C = Chroma, L = Luminance), which is a color scale that apparently maps well to human color perception.

Let's revisit our four rectangles to illustrate this. This time, though, we will allow the fill color for each rectangle to vary, and thus will include the fill as a variable in the `tiles` dataset.

###### Exercise: Mapping color
*Run the following code and then modify it by assigning the* `fill` *variable in the* `tiles` *data to the* `fill` *aesthetic.*

```{r mapping-color-ex-1, exercise=TRUE, exercise.setup="tidyverse-setup", exercise.eval=TRUE}
tiles <- tribble(
  ~x, ~y, ~fill,
  1, 1, "forestgreen",
  1, -1, "goldenrod1",
  -1, -1, "forestgreen",
  -1, 1, "goldenrod1")

ggplot(data = tiles) +
  geom_tile(mapping = aes(x = x, y = y),
            width = 1,
            height = 1,
            size = 2)
```

```{r mapping-color-ex-1-hint}
tiles <- tribble(
  ~x, ~y, ~fill,
  1, 1, "forestgreen",
  1, -1, "goldenrod1",
  -1, -1, "forestgreen",
  -1, 1, "goldenrod1")

ggplot(data = tiles) +
  geom_tile(mapping = aes(x = x, y = y, fill = ___),
            width = 1,
            height = 1,
            size = 2)
```

```{r mapping-color-ex-1-solution}
tiles <- tribble(
  ~x, ~y, ~fill,
  1, 1, "forestgreen",
  1, -1, "goldenrod1",
  -1, -1, "forestgreen",
  -1, 1, "goldenrod1")

ggplot(data = tiles) +
  geom_tile(mapping = aes(x = x, y = y, fill = fill),
            width = 1,
            height = 1,
            size = 2)
```

```{r mapping-color-ex-1-check}
gradethis::grade_code("Huh? That's not right at all! What are those colors? Impostors!!")
```

Okay, well, they're not so bad - they are two equally distant (in hue) colors in HCL color space and represent ggplot2's default discrete color palette. You can see these colors by using functions from the `scales` package as follows:

```{r}
scales::show_col(
  scales::hue_pal()(2)
)
```

It looks like "forestgreen" is mapped to "#F8766D" and "goldenrod1" is mapped to "#00BFC4". These hash-tag numbers are called hexidecimal numbers and are often used to specify color on websites (see the [color-hex website](https://www.color-hex.com/) for more information - and fun! It's like being in a paint store...). 

So how do we get the colors that are directly listed in the data? After all, our current `tiles` data is already directly representing aesthetic data. One way is to tell `ggplot2` that we want it to behave more like a location scale and use an identity mapping, which we can do by specifying the `scale_fill_identity()` function.

###### Exercise: Identity color scale
*Starting with the plot below, add the* `scale_fill_identity()` *function at the end.*

```{r scale-fill-identity-ex-1, exercise=TRUE, exercise.setup="tidyverse-setup"}
tiles <- tribble(
  ~x, ~y, ~fill,
  1, 1, "forestgreen",
  1, -1, "goldenrod1",
  -1, -1, "forestgreen",
  -1, 1, "goldenrod1")

ggplot(data = tiles) +
  geom_tile(mapping = aes(x = x, y = y, fill = fill),
            width = 1,
            height = 1,
            size = 2)
```

```{r scale-fill-identity-ex-1-solution}
tiles <- tribble(
  ~x, ~y, ~fill,
  1, 1, "forestgreen",
  1, -1, "goldenrod1",
  -1, -1, "forestgreen",
  -1, 1, "goldenrod1")

ggplot(data = tiles) +
  geom_tile(mapping = aes(x = x, y = y, fill = fill),
            width = 1,
            height = 1,
            size = 2) +
  scale_fill_identity()
```

```{r scale-fill-identity-ex-1-check}
gradethis::grade_code("That was easy!")
```

Basically, `scale_fill_identity()` tells `ggplot2` that the data already specifies the desired aesthetic values. However, most of the time our categorical data doesn't store actual color names. For example, suppose our data looked more like this:

```{r}
tiles <- tribble(
  ~x, ~y, ~royalty,
  1, 1, "william",
  1, -1, "mary",
  -1, -1, "william",
  -1, 1, "mary")
```

In this case, we can't use `scale_fill_identity()` since the levels of the `royalty` variable aren't color names. This is where the `scale_fill_manual()` comes into play, where you can specify how to map the levels of the discrete `royalty` variable to colors (i.e. _we_ get to specify the mapping of data to aesthetics).

###### Exercise: Manual color mapping
*Starting with the updated data below, add the* `scale_fill_manual()` *function and set the argument* `values` *equal to a named vector such that* `william` *gets mapped to* `forestgreen` *and* `mary` *gets mapped to* `goldenrod1`.

*Here is the definition of the* `values` *argument from the ggplot2 reference.*

> In `scale_*_manual()`, the argument `values` is a set of aesthetic values to map data values to. The values will be matched in order (usually alphabetical) with the limits of the scale, or with breaks if provided. If this is a named vector, then the values will be matched based on the names instead.

```{r scale-manual-ex-1, exercise=TRUE, exercise.setup="tidyverse-setup", exercise.eval=TRUE}
tiles <- tribble(
  ~x, ~y, ~royalty,
  1, 1, "william",
  1, -1, "mary",
  -1, -1, "william",
  -1, 1, "mary")

ggplot(data = tiles) +
  geom_tile(mapping = aes(x = x, y = y, fill = royalty),
            width = 1,
            height = 1,
            size = 2)
```

```{r scale-manual-ex-1-hint}
tiles <- tribble(
  ~x, ~y, ~royalty,
  1, 1, "william",
  1, -1, "mary",
  -1, -1, "william",
  -1, 1, "mary")

ggplot(data = tiles) +
  geom_tile(mapping = aes(x = x, y = y, fill = royalty),
            width = 1,
            height = 1,
            size = 2) +
  scale_fill_manual(values = c("william" = ___, 
                               "mary" = ___))
```

```{r scale-manual-ex-1-solution}
tiles <- tribble(
  ~x, ~y, ~royalty,
  1, 1, "william",
  1, -1, "mary",
  -1, -1, "william",
  -1, 1, "mary")

ggplot(data = tiles) +
  geom_tile(mapping = aes(x = x, y = y, fill = royalty),
            width = 1,
            height = 1,
            size = 2) +
  scale_fill_manual(values = c("william" = "forestgreen", 
                               "mary" = "goldenrod1"))
```

```{r scale-manual-ex-1-check}
gradethis::grade_code()
```

Note that we get a legend this time telling us how the fill aesthetic colors map back to the original data.

The following two definitions define the `name` and `labels` argument for color scales:

> The `name` argument gives the name of the scale. It is used as the legend title.

> The `labels` argument is a character vector giving key labels (must be same length as `breaks`). The labels will be matched in order (usually alphabetical) with the breaks of the scale. If this is a named vector, then the labels will be matched based on the names instead.

###### Exercise: Set legend titles and key labels
*Starting with the plot below, set the legend title to* `Royalty` *and the key labels* `King William` *for* `william` *and* `Queen Mary` *for* `mary`.

```{r color-legend-ex-1, exercise=TRUE, exercise.setup="tidyverse-setup", exercise.eval=TRUE}
tiles <- tribble(
  ~x, ~y, ~royalty,
  1, 1, "william",
  1, -1, "mary",
  -1, -1, "william",
  -1, 1, "mary")

ggplot(data = tiles) +
  geom_tile(mapping = aes(x = x, y = y, fill = royalty),
            width = 1,
            height = 1,
            size = 2) +
  scale_fill_manual(values = c("william" = "forestgreen", 
                               "mary" = "goldenrod1"))
```

```{r color-legend-ex-1-hint-1}
tiles <- tribble(
  ~x, ~y, ~royalty,
  1, 1, "william",
  1, -1, "mary",
  -1, -1, "william",
  -1, 1, "mary")

ggplot(data = tiles) +
  geom_tile(mapping = aes(x = x, y = y, fill = royalty),
            width = 1,
            height = 1,
            size = 2) +
  scale_fill_manual(values = c("william" = "forestgreen", 
                               "mary" = "goldenrod1"),
                    name = ___)
```

```{r color-legend-ex-1-hint-2}
tiles <- tribble(
  ~x, ~y, ~royalty,
  1, 1, "william",
  1, -1, "mary",
  -1, -1, "william",
  -1, 1, "mary")

ggplot(data = tiles) +
  geom_tile(mapping = aes(x = x, y = y, fill = royalty),
            width = 1,
            height = 1,
            size = 2) +
  scale_fill_manual(values = c("william" = "forestgreen", 
                               "mary" = "goldenrod1"),
                    name = "Royalty",
                    labels = c("william" = ___, "mary" = ___))
```

```{r color-legend-ex-1-solution}
tiles <- tribble(
  ~x, ~y, ~royalty,
  1, 1, "william",
  1, -1, "mary",
  -1, -1, "william",
  -1, 1, "mary")

ggplot(data = tiles) +
  geom_tile(mapping = aes(x = x, y = y, fill = royalty),
            width = 1,
            height = 1,
            size = 2) +
  scale_fill_manual(values = c("william" = "forestgreen", 
                               "mary" = "goldenrod1"),
                    name = "Royalty",
                    labels = c("william" = "King William", "mary" = "Queen Mary"))
```

```{r color-legend-ex-1-check}
gradethis::grade_code()
```

Just as with location scales, we can set limits with the `limits` argument. Since `royalty` is a discrete variable in this case, rather than specifying the limits using a lower and upper bound, we can just specify the limits as a subset of the levels of the `royalty` variable.

###### Exercise: Adjust key limits
*Starting with the plot below, set the* `limits` *argument so that only the "Queen Mary" rectangles show.*

```{r key-limits-ex-1, exercise=TRUE, exercise.setup="tidyverse-setup", exercise.eval = TRUE}
tiles <- tribble(
  ~x, ~y, ~royalty,
  1, 1, "william",
  1, -1, "mary",
  -1, -1, "william",
  -1, 1, "mary")

ggplot(data = tiles) +
  geom_tile(mapping = aes(x = x, y = y, fill = royalty),
            width = 1,
            height = 1,
            size = 2) +
  scale_fill_manual(values = c("william" = "forestgreen", 
                               "mary" = "goldenrod1"),
                    name = "Royalty",
                    labels = c("william" = "King William", "mary" = "Queen Mary"))
```

```{r key-limits-ex-1-solution}
tiles <- tribble(
  ~x, ~y, ~royalty,
  1, 1, "william",
  1, -1, "mary",
  -1, -1, "william",
  -1, 1, "mary")

ggplot(data = tiles) +
  geom_tile(mapping = aes(x = x, y = y, fill = royalty),
            width = 1,
            height = 1,
            size = 2) +
  scale_fill_manual(values = c("william" = "forestgreen", 
                               "mary" = "goldenrod1"),
                    name = "Royalty",
                    labels = c("william" = "King William", "mary" = "Queen Mary"),
                    limits = c("mary"))
```

```{r key-limits-ex-1-check}
gradethis::grade_code()
```

###### Exercise: Reorder keys
*Have you noticed how the keys are ordered? Looks like it's alphabetical. One nice use of* `limits` *is to reorder the legend keys. Starting with the plot below, set the* `limits` *argument so that "King William" comes before "Queen Mary" in the legend.*

```{r reorder-keys-ex-1, exercise=TRUE, exercise.setup="tidyverse-setup", exercise.eval=TRUE}
tiles <- tribble(
  ~x, ~y, ~royalty,
  1, 1, "william",
  1, -1, "mary",
  -1, -1, "william",
  -1, 1, "mary")

ggplot(data = tiles) +
  geom_tile(mapping = aes(x = x, y = y, fill = royalty),
            width = 1,
            height = 1,
            size = 2) +
  scale_fill_manual(values = c("william" = "forestgreen", 
                               "mary" = "goldenrod1"),
                    name = "Royalty",
                    labels = c("william" = "King William", "mary" = "Queen Mary"))
```

```{r reorder-keys-ex-1-solution}
tiles <- tribble(
  ~x, ~y, ~royalty,
  1, 1, "william",
  1, -1, "mary",
  -1, -1, "william",
  -1, 1, "mary")

ggplot(data = tiles) +
  geom_tile(mapping = aes(x = x, y = y, fill = royalty),
            width = 1,
            height = 1,
            size = 2) +
  scale_fill_manual(values = c("william" = "forestgreen", 
                               "mary" = "goldenrod1"),
                    name = "Royalty",
                    labels = c("william" = "King William", "mary" = "Queen Mary"),
                    limits = c("william", "mary"))
```

```{r reorder-keys-ex-1-check}
gradethis::grade_code()
```

##### Color scales: Transformations

All of the previous color scale examples covered _discrete scales_ and manual palettes. Let's explore some continuous color scales. This section will be expository only - no exercises! So just sit back and enjoy.

Getting back to the milkweed data (feel free to refresh your memory by visiting "The Data" section above), we will start by looking at a scatter plot of apical stem height in September versus apical stem height in June. Note again how we are suppressing the `data` and `mapping` argument names - they are implied since they are the first arguments of their respective functions.

```{r}
ggplot(stemdata) + 
  geom_point(aes(x = h_apical, 
                 y = h_apical.next), 
             alpha = 0.5) +
  scale_y_continuous(limits = c(0, 200))
```

This is a useful plot to illustrate stem growth over the June to September time period. We are using alpha transparency to help a little with the over-plotting occurring with the points. Also, we've clipped the vertical axis to heights in September below 200 cm due to a couple of outliers (probably a data entry error!).

One interesting additional dimension that might be interesting to add to the plot is herbivory average. How do we add a third dimension? Well, since we're talking about color, why not try color! Since herbivory average is continuous, let's start with the viridis color palette (`scale_color_viridis_c()`).

```{r}
ggplot(stemdata) + 
  geom_point(aes(x = h_apical, 
                 y = h_apical.next, 
                 color = herb_avg), 
             alpha = 0.5) + 
  scale_color_viridis_c() + 
  scale_y_continuous(limits = c(0, 200))
```

Hmmm, it seems like there is A LOT of purple corresponding to near zero herbivory averages, based on the _colorbar_ in the legend. This is a situation where it might be useful to map a log transformation of herbivory average to the colorbar, similar to what we did when hervivory average was mapped to a location aesthetic. Let's try the `trans` argument that we used previously, but now use it with the color scale.

```{r}
ggplot(stemdata) + 
  geom_point(aes(x = h_apical, 
                 y = h_apical.next, 
                 color = herb_avg), 
             alpha = 0.5) + 
  scale_color_viridis_c(trans = "log10") + 
  scale_y_continuous(limits = c(0, 200))
```

Ah, that's better! So it looks like the colorbar didn't really change but the colorbar key/ticks did change, as well as where those tick values mapped to on the colorbar. Again, it looks like a lot of the herbivory average values where _stretched_ across the colorbar, _squishing_ the larger values towards 6 (the maximum). This allows us to see better the differences in herbivory averages - the yellows stand at more, and the smaller variations near zero are more clearly visible.

Note that since we had quite a few plants that had no herbivory, when we did a log transform, we got -Inf, which gets mapped to NA since they are out of bounds of the colorbar. Where are those plants? If you look carefully, you'll notice there are a lot of points that are grey. Scales have an argument called `na.value` that you can set to a color aesthetic in order to see which plants those correspond to (or to change the default grey color, which is hard to see).

```{r}
ggplot(stemdata) + 
  geom_point(aes(x = h_apical, 
                 y = h_apical.next, 
                 color = herb_avg), 
             alpha = 0.5) + 
  scale_color_viridis_c(trans = "log10", 
                        na.value = "red") + 
  scale_y_continuous(limits = c(0, 200))
```

Whoa, there they are! Okay, well there appear to be too many of them - they are blocking the other points! Is there a way to remove them _without_ pre-filtering the data prior to visualization? Yes! You can set the value of `na.value` to NA. This will remove these "out of bounds" points from the plot.

```{r}
ggplot(stemdata) + 
  geom_point(aes(x = h_apical, 
                 y = h_apical.next, 
                 color = herb_avg), 
             alpha = 0.5) + 
  scale_color_viridis_c(trans = "log10", 
                        na.value = NA) + 
  scale_y_continuous(limits = c(0, 200))
```

Ah, even better. Hmm, since there are a lot more purple points then yellow points, maybe we should reverse the order of the colorbar - it might be easier to see fewer darker purple points against a larger array of lighter yellow points. There is an argument to color scales called `direction` that allows us to, you know, reverse the direction of the colorbar. Setting it to -1 will do the trick.

```{r}
ggplot(stemdata) + 
  geom_point(aes(x = h_apical, 
                 y = h_apical.next, 
                 color = herb_avg), 
             alpha = 0.5) + 
  scale_color_viridis_c(trans = "log10", 
                        na.value = NA, 
                        direction = -1) + 
  scale_y_continuous(limits = c(0, 200))
```

Nice! Okay, let's play with a new palette. This one is called `gradient2` which is good for creating _diverging palettes_ for situations when you want to really separate out high from low values. Let's embrace our inner Griffin while we're at it.

```{r}
ggplot(stemdata) + 
  geom_point(aes(x = h_apical, 
                 y = h_apical.next, 
                 color = herb_avg), 
             alpha = 0.5) + 
  scale_color_gradient2(low = "forestgreen", 
                        mid = "white", 
                        high = "goldenrod1", 
                        midpoint = 3,
                        na.value = "forestgreen") + 
  scale_y_continuous(limits = c(0, 200))
```

Note that I've chosen the midpoint to be in the middle of the herbivory scale (3), and I've mapped the out-of-bound values (zero herbivory plants) to the lower bound aesthetic (forestgreen).

Let's try that log transformation again for this scale. This time, we'll set the midpoint to the log (base 10) of the mean herbivory average.

```{r}
ggplot(stemdata) + 
  geom_point(aes(x = h_apical, 
                 y = h_apical.next, 
                 color = herb_avg), 
             alpha = 0.5) + 
  scale_color_gradient2(low = "forestgreen", 
                        mid = "white", 
                        high = "goldenrod1", 
                        midpoint = log10(mean(stemdata$herb_avg, na.rm = TRUE)),
                        na.value = "forestgreen",
                        trans = "log10") + 
  scale_y_continuous(limits = c(0, 200))
```

Better! Let's do one more thing. There is a shape aesthetic that we haven't talked about yet. Most point shapes only have a color aesthetic, but a select few have a color and fill aesthetic. Shape 21 is one of those that has both and is the same shape as the default (shape 19) - a circle! Let's set the shape of the points to 21 (a constant) and map herbivory average to fill instead of color (the default color is black).

```{r}
ggplot(stemdata) + 
  geom_point(aes(x = h_apical, 
                 y = h_apical.next, 
                 fill = herb_avg), 
             alpha = 0.5,
             shape = 21) + 
  scale_fill_gradient2(low = "forestgreen", 
                        mid = "white", 
                        high = "goldenrod1", 
                        midpoint = log10(mean(stemdata$herb_avg, na.rm = TRUE)),
                        na.value = "forestgreen",
                        trans = "log10") + 
  scale_y_continuous(limits = c(0, 200)) +
  theme_dark()
```

Pretty cool! This makes it much easier to see variations between herbivory and how it might relate to plant size and growth.

### Statistics

So far we've created some _primitive geoms_ using `ggplot2`. With primitive geoms, there is no additional data processing that occurs between your data and what gets mapped to aesthetics in the plot (except any transformations from the scales). However, almost all plots and graphs of interest involve computing some statistical summaries of interest and then displaying those statistical summaries using multiple primitive geoms. Thus begins our foray into `ggplot2`'s use of **statistics**, or `stat`s in ggplot2 lingo.

#### Bar plots

Let's start by creating a bar plot. We create a bar plot when

 - the explanatory variable is categorical, and
 - we want to display a statistical summary which is numerical.

Using multiple techniques, we are going to create the following bar plot showing the number of plants in each site.
```{r, echo=FALSE, fig.align="center"}
stemdata %>%
  ggplot() +
  geom_bar(aes(x = site))
```

The most common case for a bar plot is when we have one categorical variable and we want to count the number of occurrences of each category in the data. In order to do this, we create a contingency table consisting of the categories (or levels) of the variable and the counts of each level in the data.

<<SHOW PICTURE OF DATA -> CONTINGENCY TABLE>>

Once this is complete, we then create rectangles for each category with a minimum y-value at 0 and a maximum y-value at the number of occurrences for that category. We usually also make the bar widths such that they do not touch (to signify visually that the variable is categorical).

##### Exercise: Create a contingency table using `dplyr`
```{r contingency-ex-1, exercise=TRUE, exercise.setup="stemdata-setup"}
plotdata <- stemdata %>%
  group_by(___) %>%
  summarize(___)
```

```{r contingency-ex-1-solution}
plotdata <- stemdata %>%
  group_by(site) %>%
  summarize(count = n())
```

```{r contingency-ex-1-check}
gradethis::grade_code()
```

##### Exercise: Create aesthetics

```{r contingency-ex-2-setup, include=FALSE}
library(tidyverse)
stemdata <- read_csv("https://qubeshub.org/community/groups/introbiostats/File:/uploads/stemdata.csv")
plotdata <- stemdata %>%
  group_by(site) %>%
  summarize(count = n())
```

```{r contingency-ex-2, exercise=TRUE, exercise.setup="contingency-ex-2-setup"}
plotdata <- plotdata %>%
  mutate(xmin = 0.55 + 0:4,
         xmax = 1.45 + 0:4,
         ymin = 0,
         ymax = count)
```

```{r contingency-ex-2-solution}
plotdata <- plotdata %>%
  mutate(xmin = 0.55 + 0:4,
         xmax = 1.45 + 0:4,
         ymin = 0,
         ymax = count)
```

```{r contingency-ex-2-check}
gradethis::grade_code()
```

##### Exercise: Map to `geom_rect` geoms

```{r contingency-ex-3-setup, include=FALSE}
library(tidyverse)
stemdata <- read_csv("https://qubeshub.org/community/groups/introbiostats/File:/uploads/stemdata.csv")
plotdata <- stemdata %>%
  group_by(site) %>%
  summarize(count = n()) %>%
  mutate(xmin = 0.55 + 0:4,
         xmax = 1.45 + 0:4,
         ymin = 0,
         ymax = count)
```

```{r contingency-ex-3, exercise=TRUE, exercise.setup="contingency-ex-3-setup", fig.align="center"}
ggplot(data = plotdata) +
  geom_rect(aes(___))
```

```{r contingency-ex-3-solution}
ggplot(data = plotdata) +
  geom_rect(aes(
    xmin = xmin,
    xmax = xmax,
    ymin = ymin,
    ymax = ymax))
```

```{r contingency-ex-3-check}
gradethis::grade_code()
```

##### Exercise: Add labels

```{r add-labels-ex-1, exercise=TRUE, exercise.setup="contingency-ex-3-setup"}
ggplot(data = plotdata) +
  geom_rect(aes(
    xmin = xmin,
    xmax = xmax,
    ymin = ymin,
    ymax = ymax))
```

```{r add-labels-ex-1-solution}
ggplot(data = plotdata) +
  geom_rect(aes(
    xmin = xmin,
    xmax = xmax,
    ymin = ymin,
    ymax = ymax)) +
  scale_x_continuous(breaks = 1:5,
                     labels = c("BLD1", "BLD2", "PWR", "SKY", "YTB")) +
  labs(x = "site", 
       y = "count")
```

```{r add-labels-ex-1-check}
gradethis::grade_code()
```

All in one pipeline:
```{r, fig.align="center"}
stemdata %>%
  group_by(site) %>%
  summarize(count = n()) %>%
  mutate(xmin = 0.55 + 0:4,
         xmax = 1.45 + 0:4,
         ymin = 0,
         ymax = count) %>%
  ggplot() +
  geom_rect(aes(
    xmin = xmin,
    xmax = xmax,
    ymin = ymin,
    ymax = ymax)
  ) +
  scale_x_continuous(breaks = 1:5,
                     labels = c("BLD1", "BLD2", "PWR", "SKY", "YTB")) +
  labs(x = "site", 
       y = "count")
```

##### New Geom: `geom_bar`

Let's look at our first complex geom - `geom_bar` - that automates a lot of this process. Here's the command in `ggplot2` using the `geom_bar` geom that performs the data processing and aesthetic mappings free of charge:

```{r}
ggplot(data = stemdata) +
  geom_bar(aes(x = site))
```

The `geom_bar` geom performs a lot of things in this example:

 1. Map the `site` variable to the `x` aesthetic via scales (`scale_x_discrete`). Note that this maps the levels of the categorical variable to integers on the `x` scale.
 2. Use the `count` statistic to compute the contingency table of the number of occurrences for each integer (corresponding to number of plants in each site).
 3. Map the computed `x` variable back to the `x` aesthetic and computed `count` variable to the `y` aesthetic (again using scales).
 4. The `geom_bar` geom computes default values for the `xmin`, `xmax`, `ymin`, and `ymax` based on parameters for the bars and the previously mapped `x` and `y` aesthetics. Defaults for the `fill` aesthetic are also computed.
 5. Plot the results using primitive `geom_rect` geoms and assign tick labels and axes labels automatically based on the original and calculated data from the statistic.

```{r, echo=FALSE, out.width="95%", out.extra="class='center'", fig.cap="Figure 1. (1) Map the `site` variable to the `x` aesthetic, (2) count the occurrences of each integer (site) using the `count` statistic, (3) map the `x` and `y` aesthetics from the computed data, (4) compute aesthetics for the bars (xmin, xmax, ymin, ymax), and (5) map those aesthetics to the coordinate plane (in this case using `geom_rect` primitive)."}
knitr::include_graphics("images/statistics.png")
```

As mentioned above, by default, `geom_bar` uses the `count` statistic. You can manually specify the statistic by specifying the `stat` argument as a string to the geom. Also note that, by default, `geom_bar` maps the computed `count` statistic to the `y` aesthetic. The following command is fully explicit but performs the same action as above.
```{r}
ggplot(data = stemdata) +
  geom_bar(aes(x = site,
               y = after_stat(count)),
           stat = "count")
```

Note the use of the `after_stat()` function, which alerts ggplot2 that you are mapping a _computed_ variable from the stat to the `y` aesthetic. Another important thing to note is that _the mapping of scales occurs prior to the statistic_. We'll see why this is important in future exercises. Finally, the `x = site` mapping that we specified is not the full story. The real variable that gets mapped to the `x` aesthetic is the _grouped site variable_, which is the computed `x` variable. To be pedantically complete, we can use a function in `ggplot2` called `stage` that allows us to map the exact path of variables to aesthetics.
```{r}
ggplot(data = stemdata) +
  geom_bar(aes(x = stage(start = site, after_stat = x),
               y = after_stat(count)),
           stat = "count")
```

Luckily **ggplot2** hides a lot of the aesthetic defaults, but it is very helpful (in my opinion) to know exactly which commands are being used in case you want to modify or extend what is occurring. The next example illustrates this.

##### Proportions

Another common request for a bar plot is to plot the _proportion_ instead of the frequency. How to do this in `ggplot2`? The trick is in the `after_stat()` function in the call above and knowing that it can accept as an argument any expression involving the computed variables. Knowing this, we can recognize that a proportion is just going to be `count/sum(count)`, where `sum(count)` gives the total observations (or plants in this particular example). Here's the full command:

```{r}
ggplot(data = stemdata) +
  geom_bar(aes(x = site,
               y = after_stat(count/sum(count))),
           stat = "count")
```

##### Exercise: Proportions for a subset

```{r prop-subset-ex-1, exercise=TRUE, exercise.setup="tidyverse-setup"}
ggplot(data = stemdata) +
  geom_bar(aes(x = site,
               y = after_stat(count/sum(count))),
           stat = "count")
```

```{r prop-subset-ex-1-solution}
ggplot(data = stemdata) +
  geom_bar(aes(x = site,
               y = after_stat(count/sum(count))),
           stat = "count") +
  scale_x_discrete(limits = c("BLD1", "BLD2"))
```

```{r prop-subset-ex-1-check}
gradethis::grade_code("Make sure to note that the heights sum to 1!")
```

The previous exercise illustrates the importance of performing any scale operations **before** applying the statistic. Because of this order of operations, the proportions are calculated correctly!

##### New Statistic: `identity`

Another very important statistic is the "identity" statistic, which effectively skips the statistic step and goes straight to the aesthetic mapping step. One possible use of this is if we want a bar plot _but we already have the heights of the bars_. So, for example, we could create the bar plot above by first counting the plants in each site ourselves (i.e. doing the count statistic manually) and then pass that processed data to the `geom_bar` geom with the identity statistic.

```{r}
stemdata %>%
  group_by(site) %>%
  summarize(count = n()) %>%
  ggplot() +
  geom_bar(aes(x = site,
               y = count),
           stat = "identity")
```

##### Exercise: Use identity

```{r}
stemdata %>%
  filter(site %in% c("BLD1", "BLD2")) %>%
  group_by(site) %>%
  summarize(count = n()) %>%
  ggplot() +
  geom_bar(aes(x = site,
               y = count/sum(count)),
           stat = "identity")
```
##### New Geom and Statistic: `geom_histogram`

```{r}
ggplot(data = stemdata) +
  geom_histogram(aes(x = h_apical))
```

Default stat is bin.
```{r}
ggplot(data = stemdata) +
  geom_histogram(aes(x = h_apical),
                 stat = "bin")
```

Arguments for stat in geom.
```{r}
ggplot(data = stemdata) +
  geom_histogram(aes(x = h_apical),
                 bins = 20)
```

##### New Geom and Statistic: `geom_boxplot`

```{r}
ggplot(data = stemdata) +
  geom_boxplot(aes(x = site, y = h_apical))
```

```{r}
ggplot(data = stemdata) +
  geom_boxplot(aes(x = site, y = herb_avg)) +
  scale_y_continuous(trans = "log")
```

```{r}
ggplot(data = stemdata) +
  geom_boxplot(aes(x = site, y = herb_avg), outlier.color = "red") +
  scale_y_continuous(trans = "log")
```

```{r}
ggplot(data = stemdata) +
  geom_crossbar(aes(x = site, 
                    y = stage(start = h_apical, after_stat = middle),
                    ymin = after_stat(lower),
                    ymax = after_stat(upper)), 
                stat = "boxplot",
                fill = "white")
```

## Positions and Coordinates

### Positions

#### Position Stack: Stacked bar plots

```{r}
stemdata %>%
  mutate(year = as.character(year)) %>%
  ggplot() +
  geom_bar(aes(x = site, fill = year))
```

#### Position Identity

```{r}
stemdata %>%
  mutate(year = as.character(year)) %>%
  ggplot() +
  geom_bar(aes(x = site, fill = year),
           alpha = 0.5,
           color = "grey50",
           position = "identity")
```

#### Position Dodge: Side-by-side barplots

```{r}
stemdata %>%
  mutate(year = as.character(year)) %>%
  ggplot() +
  geom_bar(aes(x = site, fill = year),
           color = "grey50",
           position = "dodge")
```

#### Position Fill: Filled bar plots

```{r}
stemdata %>%
  mutate(year = as.character(year)) %>%
  ggplot() +
  geom_bar(aes(x = site, fill = year),
           position = "fill")
```

#### Position Jitter: Stripcharts

```{r}
ggplot(stemdata) +
  geom_point(aes(x = site, y = h_apical))
```

```{r}
ggplot(stemdata) +
  geom_point(aes(x = site, y = h_apical),
             position = "jitter")
```

```{r}
ggplot(stemdata) +
  geom_point(aes(x = site, y = h_apical),
             alpha = 0.2,
             position = position_jitter(width = 0.1))
```

```{r}
ggplot(stemdata, aes(x = site, y = h_apical)) +
  geom_boxplot() +
  geom_point(alpha = 0.2,
             position = position_jitter(width = 0.1))
```

```{r}
ggplot(stemdata, aes(x = site, y = h_apical)) +
  geom_boxplot(outlier.color = NA) +
  geom_point(alpha = 0.2,
             position = position_jitter(width = 0.1))
```

#### Position Nudge

```{r}
ggplot(stemdata, aes(x = site, y = h_apical)) +
  geom_boxplot(outlier.color = NA, width = 0.2,
               position = position_nudge(x = 0.3)) +
  geom_point(alpha = 0.2,
             position = position_jitter(width = 0.1))
```

### Coordinates

```{r}
ggplot(stemdata, aes(x = site, y = h_apical)) +
  geom_boxplot(outlier.color = NA, width = 0.2,
               position = position_nudge(x = 0.3)) +
  geom_point(alpha = 0.2,
             position = position_jitter(width = 0.1)) +
  coord_cartesian(ylim = c(0, 100))
```

```{r}
ggplot(stemdata, aes(x = h_apical, y = h_apical.next)) +
  geom_point(alpha = 0.2) +
  coord_cartesian(ylim = c(0, 200))
```

```{r}
ggplot(stemdata, aes(x = h_apical, y = h_apical.next)) +
  geom_point(alpha = 0.2) +
  coord_fixed(ylim = c(0, 200))
```

```{r}
ggplot(stemdata, aes(x = h_apical, y = h_apical.next)) +
  geom_point(alpha = 0.2) +
  coord_flip(ylim = c(0, 200))
```

```{r}
ggplot(data = stemdata) +
  geom_bar(aes(x = site)) +
  coord_flip()
```
```{r}
stemdata %>%
  filter(herb_avg > 0) %>%
  ggplot(aes(x = h_apical,
             y = herb_avg)) +
  geom_point(alpha = 0.5,
             shape = 21) +
  geom_smooth(method = "lm", fill = NA) +
  scale_y_continuous(trans = "log10")
```

```{r}
stemdata %>%
  filter(herb_avg > 0) %>%
  ggplot(aes(x = h_apical,
             y = herb_avg)) +
  geom_point(alpha = 0.5,
             shape = 21) +
  geom_smooth(method = "lm", fill = NA) +
  coord_trans(y = "log10")
```

```{r}
stemdata %>%
  mutate(year = as.character(year)) %>%
  ggplot() +
  geom_bar(aes(x = site,
               fill = year),
           color = "black") +
  scale_x_discrete(limits = c("BLD1")) +
  coord_polar(theta = "y", direction = -1) +
  labs(x = NULL, y = NULL) +
  theme_void()
```

```{r}
stemdata %>%
  mutate(year = as.character(year)) %>%
  ggplot() +
  geom_bar(aes(x = stage(start = site, after_stat = x + 2),
               fill = year),
           color = "black") +
  scale_x_discrete(limits = c("BLD1")) +
  coord_polar(theta = "y", direction = -1) +
  labs(x = NULL, y = NULL) +
  theme_void()
```

## Themes

Themes control the "non-data elements" of your plot.  

```{r}
stemdata %>%
  mutate(year = as.character(year)) %>%
  ggplot() +
  geom_bar(aes(x = site, fill = year)) +
  theme_classic()
```

```{r}
stemdata %>%
  mutate(year = as.character(year)) %>%
  ggplot() +
  geom_bar(aes(x = site, fill = year)) +
  theme_bw()
```

```{r}
stemdata %>%
  mutate(year = as.character(year)) %>%
  ggplot() +
  geom_bar(aes(x = site, fill = year)) +
  theme_dark()
```

```{r}
stemdata %>%
  mutate(year = as.character(year)) %>%
  ggplot() +
  geom_bar(aes(x = site, fill = year)) +
  theme_light()
```

```{r}
stemdata %>%
  mutate(year = as.character(year)) %>%
  ggplot() +
  geom_bar(aes(x = site, fill = year)) +
  theme_minimal()
```

```{r}
stemdata %>%
  mutate(year = as.character(year)) %>%
  ggplot() +
  geom_bar(aes(x = site, fill = year)) +
  theme_gray()
```

```{r}
stemdata %>%
  mutate(year = as.character(year)) %>%
  ggplot() +
  geom_bar(aes(x = site, fill = year)) +
  theme_void()
```

```{r}
stemdata %>%
  mutate(year = as.character(year)) %>%
  ggplot() +
  geom_bar(aes(x = site, fill = year)) +
  xkcd::theme_xkcd()
```

## Synthesis

### Group aesthetic

```{r}
stemdata %>%
  ggplot(aes(x = h_apical, y = h_apical.next, color = site)) +
  geom_point(alpha = 0.2) +
  geom_smooth(method = "lm") +
  coord_cartesian(ylim = c(0, 200))
```

```{r}
stemdata %>%
  ggplot(aes(x = h_apical, y = h_apical.next, group = site)) +
  geom_point(alpha = 0.2) +
  geom_smooth(method = "lm") +
  coord_cartesian(ylim = c(0, 200))
```

```{r}
stemdata %>%
  filter(site == "SKY", !is.na(h_apical), !is.na(h_apical.next)) %>%
  sample_n(10) %>%
  select(plantID, h_apical, h_apical.next) %>%
  pivot_longer(cols = starts_with("h_apical"), names_to = "time", values_to = "height") %>%
  ggplot(aes(x = time, y = height, group = plantID)) +
  geom_line() +
  geom_point(color = "red")
```

### Facets

```{r}
stemdata %>%
  ggplot(aes(x = h_apical, y = h_apical.next)) +
  geom_point(alpha = 0.2) +
  geom_smooth(method = "lm") +
  facet_wrap(~ site) +
  coord_cartesian(ylim = c(0, 200))
```

```{r}
stemdata %>%
  mutate(year = as.character(year)) %>%
  ggplot(aes(x = h_apical, y = h_apical.next, color = year)) +
  geom_point(alpha = 0.2) +
  geom_smooth(method = "lm") +
  facet_wrap(~ site) +
  coord_cartesian(ylim = c(0, 200))
```

```{r}
stemdata %>%
  mutate(year = as.character(year)) %>%
  filter(site %in% c("BLD1", "BLD2")) %>%
  ggplot(aes(x = h_apical, y = h_apical.next, color = year)) +
  geom_point(alpha = 0.2) +
  geom_smooth(method = "lm") +
  facet_wrap(vars(site), ncol = 1) +
  coord_cartesian(ylim = c(0, 200))
```

```{r}
stemdata %>%
  mutate(year = as.character(year)) %>%
  filter(site %in% c("BLD1", "BLD2")) %>%
  ggplot(aes(x = h_apical, y = h_apical.next)) +
  geom_point(alpha = 0.2) +
  geom_smooth(method = "lm") +
  facet_grid(site ~ year) +
  coord_cartesian(ylim = c(0, 200))
```

```{r}
stemdata %>%
  mutate(year = as.character(year)) %>%
  ggplot(aes(x = h_apical, y = h_apical.next)) +
  geom_point(alpha = 0.2) +
  geom_smooth(method = "lm") +
  facet_grid(site ~ year) +
  coord_cartesian(ylim = c(0, 200))
```

### Quantifying Uncertainty

```{r}
ggplot(data = stemdata) +
  geom_bar(aes(x = site, y = h_apical),
           stat = "summary",
           fun = "mean")
```

```{r}
ggplot(data = stemdata,
       aes(x = site, y = h_apical)) +
  geom_bar(stat = "summary",
           fun = "mean") +
  geom_point(stat = "summary",
             fun = "mean")
```

```{r}
ggplot(data = stemdata,
       aes(x = site, y = h_apical)) +
  geom_bar(stat = "summary",
           fun = "mean") +
  geom_errorbar(stat = "summary",
                fun.data = mean_cl_normal,
                fun.args = list(conf.int = 0.95),
                width = 0.1)
```

```{r}
ggplot(data = stemdata,
       aes(x = site, y = h_apical)) +
  geom_errorbar(stat = "summary",
                fun.data = mean_cl_normal,
                fun.args = list(conf.int = 0.95),
                width = 0.1) +
  geom_bar(stat = "summary",
           fun = "mean")
```

```{r}
ggplot(data = stemdata,
       aes(x = site, y = h_apical)) +
  geom_point(position = position_jitter(width = 0.1)) +
  geom_errorbar(stat = "summary",
                fun.data = mean_cl_normal,
                fun.args = list(conf.int = 0.95),
                width = 0.1,
                position = position_nudge(x = 0.3)) +
  geom_point(stat = "summary",
             fun = "mean",
             position = position_nudge(x = 0.3),
             color = "red",
             size = 0.5)
```

```{r}
mean_data <- stemdata %>%
  filter(!is.na(h_apical), !is.na(h_apical.next)) %>%
  group_by(site, year) %>%
  summarize(mu = mean(h_apical, na.rm = TRUE),
            mu.next = mean(h_apical.next, na.rm = TRUE))
    
stemdata %>%
  mutate(year = as.character(year)) %>%
  ggplot(aes(x = h_apical, y = h_apical.next)) +
  geom_point(alpha = 0.2) +
  geom_smooth(method = "lm",
              se = FALSE) +
  geom_hline(data = mean_data,
             mapping = aes(yintercept = mu.next),
             color = "red") +
  geom_vline(data = mean_data,
             mapping = aes(xintercept = mu),
             color = "red") +
  facet_grid(site ~ year) +
  coord_cartesian(ylim = c(0, 200))
```

```{r}
stemdata %>%
  mutate(year = as.character(year)) %>%
  filter(!is.na(h_apical), !is.na(h_apical.next)) %>%
  ggplot(aes(x = h_apical, y = h_apical.next)) +
  geom_point(alpha = 0.2) +
  geom_smooth(method = "lm",
              se = FALSE) +
  geom_segment(aes(x = 0, xend = 150, yend = after_stat(y)),
               stat = "summary",
               fun = "mean",
               color = "red") +
  geom_segment(aes(y = 0, yend = 200, xend = after_stat(x)),
               stat = "summary",
               fun = "mean",
               color = "red",
               orientation = "y") +
  facet_grid(site ~ year) +
  coord_cartesian(ylim = c(0, 200))
```

### Congratulations! You have finished "Data Visualization with ggplot2 (Part 1)"!

Please enter your name and then copy-and-paste the text in the box to the assignment on Blackboard.

```{r ui, echo=FALSE}
textInput("name", "Your name")
verbatimTextOutput("turnin")
```

```{r server, context="server"}
output$turnin <- renderText({
  stamp <- paste("Finished Data Visualization with ggplot2 - Part 1:", Sys.time(), input$name)
  paste0(stamp, "\n",
         digest::digest(stamp, "md5", serialize=FALSE))
})
```
